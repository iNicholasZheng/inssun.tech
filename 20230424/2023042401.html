<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Matthew">


    <meta name="subtitle" content="一个懂互联网的小道士！">




<title>JavaScript 排序算法 | Matthew&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Matthew&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Matthew&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JavaScript 排序算法</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Matthew</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">四月 24, 2023&nbsp;&nbsp;14:01:18</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/JavaScript/">JavaScript</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><p>冒泡排序是一种简单的排序算法，它的核心思想是将相邻的两个元素逐一比较，如果顺序不对就交换位置，直至整个序列变得有序。下面是冒泡排序的具体操作步骤：</p>
<ol>
<li>比较相邻的两个元素。如果第一个元素比第二个元素大，就交换这两个元素；</li>
<li>对每一对相邻元素做同样的工作，从开始的第一对到结尾的最后一对；</li>
<li>针对所有的元素重复上述步骤，除了最后一个；</li>
<li>重复步骤 1~3，直至排序完成。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.<span class="property">length</span>; <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">// 循环遍历数组元素，每次比较相邻两个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123; <span class="comment">// 每轮循环把最大的数放在最后面，因此内层循环次数逐步减少</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">// 如果前一个元素比后一个元素大，则交换两个元素位置</span></span><br><span class="line">                <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr; <span class="comment">// 返回已排序的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们使用了两个<code>for</code>循环来实现冒泡排序。外层循环控制排序的轮数，内层循环用于比较相邻元素并交换它们的位置。每一轮排序结束后，数组中最大的元素都会被放到数组的末尾，因此下一轮排序中就不再考虑该元素。</p>
<p>需要注意的是，在最坏情况下，即待排序序列为逆序排列时，冒泡排序的时间复杂度为 O($n^2$)。但是，在实际应用中，由于它的实现简单，对于小规模数据的排序仍然是一个较为不错的选择。</p>
<h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><p>选择排序算法是一种简单但低效的排序算法，它的时间复杂度为 O($n^2$)。该算法的基本思路如下：</p>
<ol>
<li>在待排序数组中选出最小（亦或是最大）的一个元素，存放在数组的起始位置；</li>
<li>从剩余未排序的元素中继续寻找最小（亦或是最大）的元素，然后放到已排序序列的末尾；</li>
<li>重复第二步，直至所以元素排序完毕。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>; <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">let</span> minIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">// 循环遍历数组元素，从第一个元素开始比较</span></span><br><span class="line">        minIndex = i; <span class="comment">// 假设当前元素为最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">// 从下一个元素开始比较</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123; <span class="comment">// 如果该元素比当前最小值还要小，则将其视为新的最小值</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minIndex !== i) &#123; <span class="comment">// 如果最小值的位置不是当前位置，则交换两个元素位置</span></span><br><span class="line">            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr; <span class="comment">// 返回已排序的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，首先定义了一个名为<code>selectionSort</code>的函数，它有一个参数<code>arr</code>，表示待排序的数组。函数中使用了两个嵌套的循环来实现选择排序。外层循环控制已排序部分的末尾位置，从第一个元素开始遍历到倒数第二个元素。假设当前已经排好序的区间是<code>[0, i-1]</code>，那么 $i$ 就是未排序部分的起始位置。内层循环用来寻找未排序部分中最小的元素，并将其记录在<code>minIndex</code>变量中。从 $i+1$ 位置开始遍历到数组末尾，如果发现某个位置上的元素比<code>minIndex</code>位置上的元素还要小，则将该位置赋值给<code>minIndex</code>。当内层循环结束后，我们就可以得到未排序部分中最小的元素，将其与 $i$ 位置上的元素交换，即可将该元素归入到已排序部分的末尾。最后则返回排好序的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们使用了解构赋值对两个变量的值进行了交换。我们首先创建了一个包含两个元素的数组，其中第一个元素是<code>arr[minIndex]</code>，即当前未排序部分中最小的元素，第二个元素是<code>arr[i]</code>，即当前轮次起始位置上的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[arr[minIndex], arr[i]]</span><br></pre></td></tr></table></figure>

<p>随后，我们将这个数组的值解构赋值给另外一个数组<code>[arr[i], arr[minIndex]]</code>。这样做就相当于将<code>arr[i]</code>和<code>arr[minIndex]</code>的值进行了交换。通过这种方式，我们可以省略中间变量，使得代码更加简洁。但需要注意的是，这种解构赋值的语法在 JavaScript 中被成为“数组解构赋值”，它允许我们从一个数组中提取值，然后将其赋值给变量。在本例中，由于我们要操作的元素是两个特定的数组元素，因此使用数组解构赋值来实现交换操作非常方便。</p>
<p>选择排序的优点是，它比冒泡排序更高效，并且在对小型数据集进行排序时表现良好。该算法可以就地排序，因此不需要额外的空间。然而，JavaScript 选择排序也有一些缺点。首先，在对较大数据集进行排序时，选择排序可能会变得非常缓慢，因为它需要检查每个元素并将其放置在正确的位置上。其次，即使输入数组已经排好序，选择排序仍然需要检查每个元素，这是因为算法不能利用输入数据的任何初始顺序信息。最后，JavaScript 选择排序的时间复杂度是 O($n^2$)，这意味着当数据集变得越来越大时，算法的性能将会急剧下降。</p>
<h2 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h2><p>JavaScript 插入排序是一种基本的排序算法，其主要思想是将待排序的元素一个个地插入到已排好序的元素序列之中。该算法的基本思路如下：</p>
<ol>
<li>首先，确定数组的长度，并从第二个元素开始遍历整个数组；</li>
<li>对于数组中的每个元素，都将其与已拍好序的元素序列进行比较，并找到其应该插入的位置；</li>
<li>插入新元素时，需要将其前面的所有元素向右移动一个位置，以腾出空间；</li>
<li>重复上述步骤，知道数组中所有的元素都被插入到正确的位置为止。</li>
</ol>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>; <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 循环遍历数组元素，从第二个元素开始比较</span></span><br><span class="line">        <span class="keyword">let</span> temp = arr[i]; <span class="comment">// 将当前要比较的元素存储到临时变量中</span></span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span>; <span class="comment">// 初始化j为当前元素的前一个元素，用于比较和移动元素位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123; <span class="comment">// 如果当前元素比前一个元素小，则交换两个元素的位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp; <span class="comment">// 如果当前元素比前一个元素大，则将其放在正确位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr; <span class="comment">// 返回已排序的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码示例中，我们首先定义了<code>insertionSort</code>函数来实现插入排序。函数接受一个数组作为参数，并返回一个已排序的数组。接下来，我们遍历整个数组，并将当前元素存储在一个临时变量<code>temp</code>中。然后，我们将已排好序的元素与临时变量进行比较，并找到其应该插入的位置。在这个过程中，我们使用<code>while</code>循环来向右移动已排序的元素。最后，我们将已排序的元素序列中的所有大于当前元素的元素都向右移动一个位置，并将当前元素插入到正确的位置。重复执行次过程，知道数组中的所有元素都被插入到正确的位置为止。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 外层循环控制趟数，外层循环表示无序区第一个值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 声明变量，保存无序区第一个值</span></span><br><span class="line">        <span class="keyword">let</span> current = arr[i];</span><br><span class="line">        <span class="comment">// 内层循环控制无序区第一个值在有序区合适位置的查找</span></span><br><span class="line">        <span class="comment">// 从后往前扫描有序区，前提：无序区第一个值小于有序区的值,当无序区第一个值大于有序区的值，停止扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j]; j--) &#123;</span><br><span class="line">            <span class="comment">// 插入到合适的位置</span></span><br><span class="line">            <span class="comment">// 有序区的值往后移动一位，无序的第一个值插入到最后移动元素的位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是插入排序的另一种算法，与上一种方法的区别较小。此种方法首先通过外部循环遍历数组中的每个元素，从第二个元素开始，假设第一个元素已经排序。在循环内部，将当前元素存储在<code>current</code>变量中。然后，内部循环从已排序子数组的最后一个元素开始，比较每个元素与<code>current</code>值。如果当前元素大于<code>current</code>值，则将其向右移动一个位置，为<code>current</code>值创建空间以便将其插入到正确的位置。然后持续进行比较，直到找到正确的位置或到达已排序子数组的开通。找到正确的位置后，将<code>current</code>值插入到数组中。最后，函数返回排序后的数组。</p>
<p>插入排序的时间复杂度为 O($n^2$)，其中 $n$ 是待排序元素的个数。具体来说，最坏的情况下，需要进行 $n*(n-1)&#x2F;2$ 次比较和交换操作，因此时间复杂度为 O($n^2$)。最好的情况下，如果输入数据已经接近有序，那么每次只需要进行少量比较和交换操作，时间复杂度可以达到 O($n$)。平均情况下，插入排序的时间复杂度也为 O($n^2$)。虽然插入排序相对其它排序算法来说并不是最优的，但它在某些特定场景下仍然具有较好的性能表现。例如，对于小规模数据集合或者已经接近有序的数据集合，插入排序往往可以达到较高的效率。</p>
<h2 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h2><p>希尔排序是插入排序的一种高效率实现，也被称为“缩小增量排序”。它通过将原始数组分割成若干个子数组来改进插入排序，并对每个子数组使用插入排序。这些子数组是按照一定间隔进行选择的，成为增量序列。希尔排序的核心思想是，先使得整个数组达到部分有序状态，然后再通过插入排序将整个数组变为有序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>);  <span class="comment">// 初始化增量为数组长度的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;  <span class="comment">// 当增量大于 0 时循环执行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> j = i;</span><br><span class="line">            <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;  <span class="comment">// 插入排序的过程</span></span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap / <span class="number">2</span>);  <span class="comment">// 缩小增量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码示例，首先定义了一个<code>shellSort</code>函数，它接收一个待排序的数组<code>arr</code>作为参数。然后获取数组的长度<code>len</code>，并初始化增量<code>gap</code>为数组长度的一半。接下来通过一个<code>while</code>循环不断缩小增量，直到增量为 $0$ 为止。在每个循环中，使用一个<code>for</code>循环来遍历子数组，其中<code>j</code>的初始值为<code>i</code>，即从后往前遍历子数组。接着使用一个<code>while</code>循环，如果当前元素比前面的元素小，则交换两个元素的位置，知道找到合适的位置，并将当前元素插入到该位置。经过多次缩小增量和插入排序操作后，整个数组就可以达到有序状态，最后返回数组即可。需要注意的是，这里使用的增量序列是通过<code>Math.floor(len / 2)</code>来初始化的，也可以选择其它增量序列来实现希尔排序算法。</p>
<p>希尔排序对于小规模数组，它的效率与插入排序类似，但对于大规模数组，它的效率则比插入排序要高的很多。希尔排序也是目前排序算法中较为稳定的算法之一，即相等元素的相对位置在排序前后不会改变。但是希尔排序的时间复杂度并没有被严格证明，因此难以预测其运行的时间，且希尔排序相对于其它更加先进的排序算法，性能并不是最优的。虽是如此，但依然无可否认的是，希尔排序是目前较为高效的一种排序算法，也比较适合处理大规模数据集。</p>
<h2 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h2><p>当我们需要对一个数组进行排序时，归并排序算法采用分治思想来解决问题。在分治思想中，“分”指的是将问题拆分成更小的子问题；“治”指的是解决子问题。具体地，对于一个待排序的数组，归并排序算法会将其分成左右两个子数组，对这两个子数组风别递归调用归并排序算法，知道子数组长度为 $1$ 或 $0$，即只剩下一个元素或者没有元素，此时子数组已经有序，可以开始进行合并。</p>
<p>在合并过程中，将两个有序的子数组合并成一个有序数组。具体地，使用两个指针分别只想两个子数组的开头，比较两个指针所指元素大小，将较小的元素放入结果数组中，并将对应指针向后移动一位。当其中一个数组的指针到达末尾的时候，将另一个数组中剩余的元素全部放入到结果数组中。这样的话最终得到的就是一个有序数组。因为每次将一个数组划分成两个子数组，所以归并算法的时间复杂度为 O($nlogn$)。缺点则是需要额外的存储空间来保存中间结果，所以空间复杂度也是 O($n$)。因为归并算法稳定且效率高，所以在实际应用中得到了广泛的应用。</p>
<p>简单来说，归并排序算法的基本思想即为将一个大数组分为两个较小的子数组，然后递归地对这两个子数组进行排序，最后将两个已排序的子数组合并成为一个有序的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mergeSort() 函数接受一个数组作为参数，并返回一个排序后的新数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的数组长度小于等于 1，那么它已经是有序的了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算数组的中间位置，并将数组分成左右两个子数组</span></span><br><span class="line">    <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> leftArr = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">const</span> rightArr = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line">    <span class="comment">// 对左右两个子数组递归调用 mergeSort() 函数进行排序，并将结果合并</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(leftArr), <span class="title function_">mergeSort</span>(rightArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge() 函数接受两个已排序的子数组作为参数，并返回一个合并后的新数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">leftArr, rightArr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []; <span class="comment">// 新数组，用于存储合并后的结果</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 分别代表左右两个子数组的当前元素的下标</span></span><br><span class="line">    <span class="comment">// 比较左右两个子数组的当前元素大小，将较小的元素添加到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftArr.<span class="property">length</span> &amp;&amp; j &lt; rightArr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt; rightArr[j]) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(leftArr[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(rightArr[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的元素添加到新数组中</span></span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">concat</span>(leftArr.<span class="title function_">slice</span>(i)).<span class="title function_">concat</span>(rightArr.<span class="title function_">slice</span>(j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中，<code>mergeSort()</code>函数首先检查传递给它的数组长度是否小于或者等于 $1$，如果是，则直接返回该数组。否则，它使用<code>slice()</code>方法将数组切割成两个较小的子数组，并递归调用自身来对两个子数组进行排序。最后，它调用<code>merge()</code>函数来将排序后的两个子数组合并成一个有序的数组。<code>merge()</code>函数使用两个指针<code>i</code>和<code>j</code>来遍历左右子数组，比较它们的元素大小，并将较小的元素推入结果数组中。最后，如果一个子数组的所有元素都被添加到了结果数组中，那么另一个子数组中剩余的元素也会被添加到结果数组中。</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/JavaScript/"># JavaScript</a>
                    
                        <a href="/tags/%E7%AE%97%E6%B3%95/"># 算法</a>
                    
                        <a href="/tags/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"># 经典面试题</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">Back</a>
                <span>· </span>
                <a href="/">Home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/20230423/2023042304.html">正则表达式字符组重点详解</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>Copyright © 2020-2023 Matthew. All Rights Reserved</span>
    </div>
</footer>

    </div>
</body>

</html>